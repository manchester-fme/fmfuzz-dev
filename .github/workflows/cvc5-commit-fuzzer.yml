name: CVC5 Commit Fuzzer

on:
  workflow_dispatch:
    inputs:
      cvc5_commit_hash:
        description: 'Optional: CVC5 commit hash to analyze (defaults to HEAD)'
        required: false
        type: string
      coverage_commit_hash:
        description: 'Optional: CVC5 commit hash for coverage mapping (defaults to latest in S3)'
        required: false
        type: string
      stop_buffer_minutes:
        description: 'Optional: Minutes before timeout to stop fuzzing (default: 5)'
        required: false
        type: number
        default: 5
  schedule:
    - cron: '45 0,6,12,18 * * *'  # Run every 6 hours starting at 00:45 (00:45, 06:45, 12:45, 18:45)

jobs:
  check-latest-build:
    runs-on: ubuntu-latest
    outputs:
      fuzzing_needed: ${{ steps.set-outputs.outputs.fuzzing_needed }}
      sha: ${{ steps.set-outputs.outputs.sha }}
      commit_to_fuzz: ${{ steps.set-outputs.outputs.commit_to_fuzz }}
      latest_build: ${{ steps.set-outputs.outputs.latest_build }}
      is_manual_run: ${{ steps.set-outputs.outputs.is_manual_run }}
      binary_available: ${{ steps.set-outputs.outputs.binary_available }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: pip install boto3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Get commit to fuzz and latest build
        id: set-outputs
        env:
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
        run: |
          set +e  # Don't exit on error - handle errors gracefully
          # If workflow_dispatch with commit hash provided, use that commit
          # Otherwise (scheduled OR workflow_dispatch without commit), use fuzzer to select
          if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ -n "${{ inputs.cvc5_commit_hash }}" ]; then
            COMMIT_TO_FUZZ="${{ inputs.cvc5_commit_hash }}"
            # For manual runs, get latest build to use
            echo "üîç Attempting to get latest build from S3..."
            LATEST_BUILD=$(python -c "from scripts.scheduling.s3_state import get_state_manager; m = get_state_manager('cvc5'); print(m.get_latest_available_build() or '')" 2>&1)
            PYTHON_EXIT=$?
            echo "DEBUG: Python exit code: $PYTHON_EXIT"
            echo "DEBUG: LATEST_BUILD result: '${LATEST_BUILD}'"
            echo "DEBUG: LATEST_BUILD length: ${#LATEST_BUILD}"
            # Extract just the commit hash (last line, filter out debug messages)
            LATEST_BUILD=$(echo "$LATEST_BUILD" | grep -E '^[a-f0-9]{40}$' | tail -1 || echo '')
            if [ -z "$LATEST_BUILD" ]; then
              echo "‚ö†Ô∏è  No latest build available, using provided commit as build"
              LATEST_BUILD="$COMMIT_TO_FUZZ"
            fi
            echo "üî® Using provided commit: $COMMIT_TO_FUZZ with build: $LATEST_BUILD"
            echo "fuzzing_needed=true" >> $GITHUB_OUTPUT
            echo "commit_to_fuzz=$COMMIT_TO_FUZZ" >> $GITHUB_OUTPUT
            echo "latest_build=$LATEST_BUILD" >> $GITHUB_OUTPUT
            echo "sha=$COMMIT_TO_FUZZ" >> $GITHUB_OUTPUT
            echo "is_manual_run=true" >> $GITHUB_OUTPUT
            echo "binary_available=true" >> $GITHUB_OUTPUT
          else
            # Scheduled run OR workflow_dispatch without commit - use fuzzer to select
            # Capture stdout for result, stderr for debugging
            echo "üîç Running fuzzer.py to select commit..."
            PYTHONPATH="${{ github.workspace }}" python scripts/scheduling/fuzzer.py cvc5 select >/tmp/fuzzer_stdout.txt 2>/tmp/fuzzer_stderr.txt || true
            RESULT=$(cat /tmp/fuzzer_stdout.txt 2>/dev/null || echo "")
            STDERR_OUTPUT=$(cat /tmp/fuzzer_stderr.txt 2>/dev/null || echo "")
            echo "=== Fuzzer Debug Output ==="
            if [ -n "$STDERR_OUTPUT" ]; then
              echo "$STDERR_OUTPUT"
            else
              echo "(no stderr output)"
            fi
            echo "=== Fuzzer Result (stdout) ==="
            echo "Result: '$RESULT'"
            echo "Word count: $(echo "$RESULT" | wc -w)"
            if [ -n "$RESULT" ] && [ "$(echo "$RESULT" | wc -w)" -eq 2 ]; then
              COMMIT_TO_FUZZ=$(echo "$RESULT" | awk '{print $1}')
              LATEST_BUILD=$(echo "$RESULT" | awk '{print $2}')
              echo "‚úÖ Found commit to fuzz: $COMMIT_TO_FUZZ, using latest build: $LATEST_BUILD"
              echo "fuzzing_needed=true" >> $GITHUB_OUTPUT
              echo "commit_to_fuzz=$COMMIT_TO_FUZZ" >> $GITHUB_OUTPUT
              echo "latest_build=$LATEST_BUILD" >> $GITHUB_OUTPUT
              echo "sha=$COMMIT_TO_FUZZ" >> $GITHUB_OUTPUT
              echo "is_manual_run=false" >> $GITHUB_OUTPUT
              echo "binary_available=true" >> $GITHUB_OUTPUT
            else
              echo "‚è≠Ô∏è  No commits in fuzzing schedule or no builds available"
              echo "fuzzing_needed=false" >> $GITHUB_OUTPUT
              echo "commit_to_fuzz=" >> $GITHUB_OUTPUT
              echo "latest_build=" >> $GITHUB_OUTPUT
              echo "sha=" >> $GITHUB_OUTPUT
              echo "is_manual_run=false" >> $GITHUB_OUTPUT
              echo "binary_available=false" >> $GITHUB_OUTPUT
            fi
          fi

  skip-fuzzing:
    needs: check-latest-build
    if: |
      github.event_name == 'schedule' &&
      (needs.check-latest-build.outputs.fuzzing_needed == 'false' || needs.check-latest-build.outputs.binary_available == 'false')
    runs-on: ubuntu-latest
    steps:
      - name: Skip fuzzing
        run: |
          if [ "${{ needs.check-latest-build.outputs.fuzzing_needed }}" == "false" ]; then
            echo "‚úÖ No builds available - skipping fuzzing"
          else
            echo "‚ùå Production binary not available - skipping fuzzing"
          fi

  commit-fuzzer:
    needs: check-latest-build
    if: |
      (github.event_name == 'workflow_dispatch') ||
      (github.event_name == 'schedule' && needs.check-latest-build.outputs.fuzzing_needed == 'true' && needs.check-latest-build.outputs.binary_available == 'true')
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.extract-tests.outputs.matrix }}
      total_tests: ${{ steps.extract-tests.outputs.total_tests }}
      total_jobs: ${{ steps.extract-tests.outputs.total_jobs }}
      commit_hash: ${{ steps.get-commit.outputs.commit_hash }}
    permissions:
      actions: read
      contents: read
    
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      
      - name: Install LLVM/Clang 17
        uses: KyleMayes/install-llvm-action@v2
        with:
          version: '17'

      - name: Add LLVM to PATH
        run: echo "${{ env.LLVM_PATH }}/bin" >> $GITHUB_PATH

      - name: Export LIBCLANG_PATH
        run: echo "LIBCLANG_PATH=${{ env.LLVM_PATH }}/lib" >> $GITHUB_ENV

      - name: Install system development packages
        run: |
          echo "Installing essential development packages..."
          sudo apt-get update
          
          # Install ONLY GCC 14 and essential packages (remove conflicting versions)
          sudo apt-get install -y \
            build-essential \
            libc6-dev \
            gcc \
            g++ \
            binutils \
            libstdc++-14-dev \
            libc++-dev \
            libc++abi-dev \
            zlib1g \
            zlib1g-dev
          
          echo "Installation completed"
      
      - name: Install Python dependencies
        run: |
          pip install gitpython unidiff "libclang==17.0.6"

      - name: Clone CVC5 repository
        run: |
          if [ -d "cvc5" ]; then
            echo "CVC5 directory already exists, skipping clone"
          else
            git clone https://github.com/cvc5/cvc5.git cvc5
          fi

      - name: Checkout commit to fuzz
        working-directory: cvc5
        run: |
          COMMIT_TO_FUZZ="${{ needs.check-latest-build.outputs.commit_to_fuzz }}"
          echo "üî® Checking out commit to fuzz: $COMMIT_TO_FUZZ"
          git fetch origin
          git checkout $COMMIT_TO_FUZZ
          echo "Checked out commit: $(git rev-parse HEAD)"

      - name: Get CVC5 commit hash
        id: get-commit
        working-directory: cvc5
        run: |
          COMMIT_HASH=$(git rev-parse HEAD)
          echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
          echo "CVC5 commit hash: $COMMIT_HASH"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Download production binary from S3 (for headers and compile_commands.json)
        id: download-production-binary
        continue-on-error: true
        run: |
          mkdir -p artifacts
          LATEST_BUILD="${{ needs.check-latest-build.outputs.latest_build }}"
          S3_KEY="solvers/cvc5/builds/v2/production/${LATEST_BUILD}.tar.gz"
          
          if aws s3api head-object \
            --bucket ${{ secrets.AWS_S3_BUCKET }} \
            --key "$S3_KEY" >/dev/null 2>&1; then
            echo "üì• Downloading production binary for latest build: $LATEST_BUILD (for headers and compile_commands.json)"
            aws s3 cp \
              s3://${{ secrets.AWS_S3_BUCKET }}/$S3_KEY \
              artifacts/artifacts.tar.gz
            echo "artifacts_available=true" >> $GITHUB_OUTPUT
          else
            echo "WARNING: Production binary not found in S3 for $LATEST_BUILD, will build as fallback"
            echo "artifacts_available=false" >> $GITHUB_OUTPUT
          fi

      - name: Extract headers and compile_commands.json
        id: extract-artifacts
        if: steps.download-production-binary.outputs.artifacts_available == 'true'
        run: |
          if [ -f "artifacts/artifacts.tar.gz" ]; then
            ./scripts/cvc5/extract_build_artifacts.sh artifacts/artifacts.tar.gz cvc5/build true
            if [ -f "cvc5/build/compile_commands.json" ]; then
              echo "‚úÖ Headers and compile_commands.json extracted successfully"
              echo "artifacts_available=true" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è compile_commands.json extraction failed"
              echo "artifacts_available=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "artifacts_available=false" >> $GITHUB_OUTPUT
          fi

      - name: Build cvc5 static binary (fallback for headers and compile_commands.json)
        if: steps.extract-artifacts.outputs.artifacts_available != 'true'
        run: |
          if [ ! -f "cvc5/build/compile_commands.json" ]; then
            echo "üî® Building CVC5 static binary as fallback to get headers and compile_commands.json"
            ./scripts/cvc5/build.sh --static
          else
            echo "‚úÖ Using artifacts from S3, skipping build"
          fi
      
      - name: Configure AWS credentials for coverage download
        uses: aws-actions/configure-aws-credentials@v5.1.0
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Download coverage map from S3
        id: download-coverage
        run: |
          if [ -n "${{ inputs.coverage_commit_hash }}" ]; then
            # Use specified commit hash
            COVERAGE_COMMIT="${{ inputs.coverage_commit_hash }}"
            S3_KEY="solvers/cvc5/coverage-mappings/coverage_mapping-${COVERAGE_COMMIT}.json.gz"
            
            if aws s3api head-object \
              --bucket ${{ secrets.AWS_S3_BUCKET }} \
              --key "$S3_KEY" >/dev/null 2>&1; then
              echo "üì• Downloading coverage mapping for commit: ${COVERAGE_COMMIT}"
              aws s3 cp \
                s3://${{ secrets.AWS_S3_BUCKET }}/$S3_KEY \
                coverage_mapping.json.gz
              echo "coverage_found=true" >> $GITHUB_OUTPUT
            else
              echo "‚ùå Coverage mapping not found for commit: ${COVERAGE_COMMIT}"
              echo "coverage_found=false" >> $GITHUB_OUTPUT
            fi
          else
            # Find latest coverage mapping
            echo "üîç Finding latest coverage mapping in S3..."
            LATEST=$(aws s3 ls s3://${{ secrets.AWS_S3_BUCKET }}/solvers/cvc5/coverage-mappings/ \
              | grep "coverage_mapping-" \
              | sort -r \
              | head -n 1 \
              | awk '{print $4}' || echo "")
            
            if [ -n "$LATEST" ]; then
              echo "üì• Downloading latest coverage mapping: $LATEST"
              aws s3 cp \
                s3://${{ secrets.AWS_S3_BUCKET }}/solvers/cvc5/coverage-mappings/$LATEST \
                coverage_mapping.json.gz
              echo "coverage_found=true" >> $GITHUB_OUTPUT
              echo "coverage_file=$LATEST" >> $GITHUB_OUTPUT
            else
              echo "‚ùå No coverage mappings found in S3"
              echo "coverage_found=false" >> $GITHUB_OUTPUT
            fi
          fi
      
      - name: Extract coverage map
        if: steps.download-coverage.outputs.coverage_found == 'true'
        run: |
          gunzip coverage_mapping.json.gz
          ls -la coverage_mapping.json
          echo "‚úÖ Coverage mapping extracted successfully"
      
      - name: Coverage mapping not found
        if: steps.download-coverage.outputs.coverage_found != 'true'
        run: |
          echo "‚ùå Coverage mapping not found. Please run coverage mapper workflow first or specify a valid coverage_commit_hash."
          exit 1

      - name: Run Commit Fuzzer and create matrix
        id: extract-tests
        working-directory: cvc5
        env:
          SKIP_COVERAGE_ENFORCEMENT: "true"
          MAX_JOBS: 9
          CVC5_COMMIT_HASH: ${{ steps.get-commit.outputs.commit_hash }}
        run: |
          # Run commit fuzzer with matrix output (1 commit instead of 50)
          # Max 9 jobs per solver (18 total for both z3 and cvc5) to leave space for building and management
          # Tests per job is calculated dynamically to fit within MAX_JOBS
          # To scale: change MAX_JOBS to 200+ (will automatically adjust tests_per_job)
          ${{ github.workspace }}/scripts/cvc5/commit_fuzzer/run_prepare_commit_fuzzer.sh \
            --python-script ${{ github.workspace }}/scripts/cvc5/commit_fuzzer/prepare_commit_fuzzer.py \
            --coverage-file ../coverage_mapping.json \
            --compile-commands build \
            --output-matrix fuzzer_matrix.json \
            --max-jobs $MAX_JOBS \
            1
          
          if [ ! -f "fuzzer_matrix.json" ]; then
            echo "No matrix file created (no functions found or no tests), setting empty outputs"
            echo "matrix={\"include\":[]}" >> $GITHUB_OUTPUT
            echo "total_tests=0" >> $GITHUB_OUTPUT
            echo "total_jobs=0" >> $GITHUB_OUTPUT
            echo "‚úÖ No functions to fuzz - ending gracefully"
          else
            # Read matrix data and output to GitHub Actions
            MATRIX=$(jq -c '.matrix' fuzzer_matrix.json)
            TOTAL_TESTS=$(jq -r '.total_tests' fuzzer_matrix.json)
            TOTAL_JOBS=$(jq -r '.total_jobs' fuzzer_matrix.json)
            
            echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
            echo "total_tests=$TOTAL_TESTS" >> $GITHUB_OUTPUT
            echo "total_jobs=$TOTAL_JOBS" >> $GITHUB_OUTPUT
            
            echo "Matrix created with $TOTAL_JOBS jobs for $TOTAL_TESTS tests"
          fi

  fuzzer-jobs:
    needs: [check-latest-build, commit-fuzzer]
    if: needs.commit-fuzzer.result == 'success' && needs.commit-fuzzer.outputs.total_tests != '' && needs.commit-fuzzer.outputs.total_tests != '0'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.commit-fuzzer.outputs.matrix) }}
    permissions:
      actions: read
      contents: read
    
    steps:
      - name: Record job start time
        run: echo "$(date +%s)" > /tmp/job_start_${GITHUB_RUN_ID}_${{ matrix.job_id }}.txt
      
      - name: Checkout
        uses: actions/checkout@v5
      
      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            python3 \
            python3-pip \
            unzip \
            wget
          # Clean up apt cache to save space
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*

      - name: Install fuzzing dependencies
        run: |
          pip install antlr4-python3-runtime==4.9.2
          pip install psutil
          git clone https://github.com/testsmt/yinyang.git
          cd yinyang
          pip install -e .
          cd ..
          # Clean up pip cache
          pip cache purge || true

      - name: Download solver binaries
        run: |
          mkdir -p ${{ github.workspace }}/solvers
          
          # Old solver versions (cvc4, z3-4.8.7) are not needed - they're commented out in the code
          # Commented out to save space, but kept for reference
          # # Download cvc4-1.6
          # wget -q https://cvc4.cs.stanford.edu/downloads/builds/x86_64-linux-opt/cvc4-1.6-x86_64-linux-opt \
          #   -O ${{ github.workspace }}/solvers/cvc4-1.6
          # chmod +x ${{ github.workspace }}/solvers/cvc4-1.6
          # 
          # # Download z3-4.8.7
          # wget -q https://github.com/Z3Prover/z3/releases/download/z3-4.8.7/z3-4.8.7-x64-ubuntu-16.04.zip -O /tmp/z3.zip
          # unzip -q /tmp/z3.zip -d /tmp
          # cp /tmp/z3-4.8.7-x64-ubuntu-16.04/bin/z3 ${{ github.workspace }}/solvers/z3-4.8.7
          # cp /tmp/z3-4.8.7-x64-ubuntu-16.04/bin/libz3.so ${{ github.workspace }}/solvers/
          # chmod +x ${{ github.workspace }}/solvers/z3-4.8.7
          # rm -rf /tmp/z3.zip /tmp/z3-4.8.7-x64-ubuntu-16.04

      - name: Clone CVC5 repository
        run: |
          if [ -d "cvc5" ]; then
            echo "CVC5 directory already exists, skipping clone"
          else
            git clone https://github.com/cvc5/cvc5.git cvc5
          fi

      - name: Checkout same commit as first job
        working-directory: cvc5
        run: |
          git fetch origin
          git checkout ${{ needs.commit-fuzzer.outputs.commit_hash }}
          echo "Checked out commit: $(git rev-parse HEAD)"
      
      - name: Clean up git repositories to save space
        run: |
          # Remove .git directories from cloned repos (not needed for fuzzing)
          rm -rf cvc5/.git yinyang/.git || true
          echo "‚úÖ Cleaned up git repositories"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Download latest production binary from S3
        id: download-production-binary
        continue-on-error: true
        run: |
          mkdir -p artifacts
          LATEST_BUILD="${{ needs.check-latest-build.outputs.latest_build }}"
          S3_KEY="solvers/cvc5/builds/v2/production/${LATEST_BUILD}.tar.gz"
          
          echo "DEBUG: Checking for binary at S3 key: $S3_KEY"
          echo "DEBUG: Latest build commit: $LATEST_BUILD"
          echo "DEBUG: Bucket: ${{ secrets.AWS_S3_BUCKET }}"
          
          if aws s3api head-object \
            --bucket ${{ secrets.AWS_S3_BUCKET }} \
            --key "$S3_KEY" 2>&1; then
            echo "‚úÖ Binary exists in S3, downloading..."
            if aws s3 cp \
              s3://${{ secrets.AWS_S3_BUCKET }}/$S3_KEY \
              artifacts/artifacts.tar.gz; then
              echo "‚úÖ Binary downloaded successfully"
              ls -lh artifacts/artifacts.tar.gz
              echo "binary_available=true" >> $GITHUB_OUTPUT
            else
              echo "‚ùå Binary download failed"
              echo "binary_available=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "WARNING: Production binary not found in S3 at key: $S3_KEY"
            echo "DEBUG: Attempting to list objects in production directory..."
            aws s3 ls s3://${{ secrets.AWS_S3_BUCKET }}/solvers/cvc5/builds/v2/production/ | head -5 || echo "Failed to list objects"
            echo "binary_available=false" >> $GITHUB_OUTPUT
          fi

      - name: Extract production binary
        id: extract-production-binary
        if: steps.download-production-binary.outputs.binary_available == 'true'
        run: |
          if [ -f "artifacts/artifacts.tar.gz" ]; then
            ./scripts/cvc5/extract_build_artifacts.sh artifacts/artifacts.tar.gz cvc5/build false
            if [ -f "cvc5/build/bin/cvc5" ]; then
              echo "‚úÖ Production binary extracted successfully"
              # Remove downloaded artifact to save space
              rm -f artifacts/artifacts.tar.gz
            else
              echo "‚ö†Ô∏è Binary extraction failed"
              echo "binary_available=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "binary_available=false" >> $GITHUB_OUTPUT
          fi

      - name: Build cvc5 static binary (fallback)
        run: |
          if [ ! -f "cvc5/build/bin/cvc5" ]; then
            echo "üî® Building CVC5 static binary as fallback (binary not available from S3)"
            ./scripts/cvc5/build.sh --static
          else
            echo "‚úÖ Using binary from S3, skipping build"
          fi

      - name: Get latest Z3 build from S3
        id: get-z3-build
        env:
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
        run: |
          echo "üîç Getting latest Z3 build from S3..."
          LATEST_Z3_BUILD=$(python -c "from scripts.scheduling.s3_state import get_state_manager; m = get_state_manager('z3'); print(m.get_latest_available_build() or '')" 2>&1)
          LATEST_Z3_BUILD=$(echo "$LATEST_Z3_BUILD" | grep -E '^[a-f0-9]{40}$' | tail -1 || echo '')
          if [ -z "$LATEST_Z3_BUILD" ]; then
            echo "‚ö†Ô∏è  No latest Z3 build available"
            echo "z3_build_available=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Latest Z3 build: $LATEST_Z3_BUILD"
            echo "z3_build=$LATEST_Z3_BUILD" >> $GITHUB_OUTPUT
            echo "z3_build_available=true" >> $GITHUB_OUTPUT
          fi

      - name: Download Z3 production binary from S3
        id: download-z3-binary
        if: steps.get-z3-build.outputs.z3_build_available == 'true'
        continue-on-error: true
        run: |
          mkdir -p artifacts-z3
          LATEST_Z3_BUILD="${{ steps.get-z3-build.outputs.z3_build }}"
          S3_KEY="solvers/z3/builds/v2/production/${LATEST_Z3_BUILD}.tar.gz"
          
          echo "DEBUG: Checking for Z3 binary at S3 key: $S3_KEY"
          echo "DEBUG: Latest Z3 build commit: $LATEST_Z3_BUILD"
          
          if aws s3api head-object \
            --bucket ${{ secrets.AWS_S3_BUCKET }} \
            --key "$S3_KEY" 2>&1; then
            echo "‚úÖ Z3 binary exists in S3, downloading..."
            if aws s3 cp \
              s3://${{ secrets.AWS_S3_BUCKET }}/$S3_KEY \
              artifacts-z3/artifacts.tar.gz; then
              echo "‚úÖ Z3 binary downloaded successfully"
              ls -lh artifacts-z3/artifacts.tar.gz
              echo "z3_binary_available=true" >> $GITHUB_OUTPUT
            else
              echo "‚ùå Z3 binary download failed"
              echo "z3_binary_available=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "WARNING: Z3 production binary not found in S3 at key: $S3_KEY"
            echo "z3_binary_available=false" >> $GITHUB_OUTPUT
          fi

      - name: Extract Z3 production binary
        id: extract-z3-binary
        if: steps.download-z3-binary.outputs.z3_binary_available == 'true'
        run: |
          if [ -f "artifacts-z3/artifacts.tar.gz" ]; then
            mkdir -p z3/build
            ./scripts/z3/extract_build_artifacts.sh artifacts-z3/artifacts.tar.gz z3/build false
            if [ -f "z3/build/z3" ]; then
              echo "‚úÖ Z3 production binary extracted successfully"
              # Make z3 available in PATH (prepend to ensure it takes precedence over pip-installed z3-solver)
              mkdir -p ${{ github.workspace }}/solvers
              cp z3/build/z3 ${{ github.workspace }}/solvers/z3
              chmod +x ${{ github.workspace }}/solvers/z3
              # Prepend to PATH so S3 binary is used first (GITHUB_PATH automatically prepends)
              echo "${{ github.workspace }}/solvers" >> $GITHUB_PATH
              # Remove downloaded artifact to save space
              rm -f artifacts-z3/artifacts.tar.gz
              echo "z3_binary_available=true" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è Z3 binary extraction failed"
              echo "z3_binary_available=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "z3_binary_available=false" >> $GITHUB_OUTPUT
          fi

      - name: Install z3-solver as fallback
        if: |
          (steps.get-z3-build.outputs.z3_build_available != 'true') ||
          (steps.download-z3-binary.outputs.z3_binary_available != 'true') ||
          (steps.extract-z3-binary.outputs.z3_binary_available != 'true')
        run: |
          echo "‚ö†Ô∏è Z3 binary from S3 not available, installing z3-solver as fallback"
          pip install z3-solver

      - name: Verify solver binaries
        run: |
          # Old solver versions are not used (commented out in code)
          # ${{ github.workspace }}/solvers/cvc4-1.6 --version
          # ${{ github.workspace }}/solvers/z3-4.8.7 --version
          z3 --version

      - name: Run Simple Fuzzer on assigned tests
        working-directory: cvc5
        run: |
          JOB_START=$(cat /tmp/job_start_${GITHUB_RUN_ID}_${{ matrix.job_id }}.txt)
          
          # Use provided stop_buffer_minutes or default 5 minutes
          STOP_BUFFER=${{ inputs.stop_buffer_minutes || 5 }}
          
          ${{ github.workspace }}/scripts/cvc5/commit_fuzzer/simple_commit_fuzzer.py \
            --tests-json '${{ toJson(matrix.tests) }}' \
            --job-id '${{ matrix.job_id }}' \
            --tests-root 'test/regress/cli' \
            --job-start-time "$JOB_START" \
            --stop-buffer-minutes ${STOP_BUFFER} \
            --iterations 250 \
            --cvc5-path ./build/bin/cvc5
            # Old solver versions are not used for now
            # --z3-old-path ${{ github.workspace }}/solvers/z3-4.8.7 \
            # --cvc4-path ${{ github.workspace }}/solvers/cvc4-1.6 \
      
      - name: Upload bugs as artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: bugs-job-${{ matrix.job_id }}
          path: cvc5/bugs
          retention-days: 1
          if-no-files-found: ignore

  collect-bugs:
    needs: [commit-fuzzer, fuzzer-jobs]
    if: always() && needs.commit-fuzzer.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      actions: read
      contents: read
    
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      
      - name: Download all bug artifacts
        uses: actions/download-artifact@v4
        with:
          path: bugs-artifacts
          pattern: bugs-job-*
          merge-multiple: false
      
      - name: Combine all bugs
        id: combine-bugs
        run: |
          mkdir -p combined-bugs
          
          # Copy all bugs from all job artifacts (if any exist)
          # Each artifact is in bugs-artifacts/bugs-job-{job_id}/bugs/
          if [ -d "bugs-artifacts" ]; then
            find bugs-artifacts -name "*.smt2" -type f -exec cp {} combined-bugs/ \; 2>/dev/null || true
          else
            echo "No bug artifacts directory found (no bugs were found in any job)"
          fi
          
          # Count bugs
          BUG_COUNT=$(find combined-bugs -name "*.smt2" -type f 2>/dev/null | wc -l || echo "0")
          echo "Total bugs found: $BUG_COUNT"
          echo "bug_count=$BUG_COUNT" >> $GITHUB_OUTPUT
          
          if [ "$BUG_COUNT" -eq 0 ]; then
            echo "‚úÖ No bugs found, skipping upload"
            echo "bugs_found=false" >> $GITHUB_OUTPUT
          else
            echo "bugs_found=true" >> $GITHUB_OUTPUT
            # List all bugs
            echo "Bugs found:"
            find combined-bugs -name "*.smt2" -type f | sort
          fi
      
      - name: Create bugs archive
        id: create-archive
        if: steps.combine-bugs.outputs.bugs_found == 'true'
        run: |
          COMMIT_HASH="${{ needs.commit-fuzzer.outputs.commit_hash }}"
          COMMIT_SHORT="${COMMIT_HASH:0:7}"
          TIMESTAMP=$(date +%s)
          ARCHIVE_NAME="bugs-${COMMIT_SHORT}-${TIMESTAMP}.tar.gz"
          cd combined-bugs
          tar -czf ../${ARCHIVE_NAME} .
          cd ..
          ARCHIVE_SIZE=$(du -h ${ARCHIVE_NAME} | cut -f1)
          echo "Created archive: ${ARCHIVE_NAME} ($ARCHIVE_SIZE)"
          echo "archive_name=${ARCHIVE_NAME}" >> $GITHUB_OUTPUT
      
      - name: Configure AWS credentials
        if: steps.combine-bugs.outputs.bugs_found == 'true'
        uses: aws-actions/configure-aws-credentials@v5.1.0
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Upload bugs to S3
        if: steps.combine-bugs.outputs.bugs_found == 'true'
        run: |
          ARCHIVE_NAME="${{ steps.create-archive.outputs.archive_name }}"
          S3_KEY="solvers/cvc5/bugs/${ARCHIVE_NAME}"
          
          if [ ! -f "$ARCHIVE_NAME" ]; then
            echo "‚ùå Error: Archive file not found: $ARCHIVE_NAME"
            exit 1
          fi
          
          aws s3 cp \
            ${ARCHIVE_NAME} \
            s3://${{ secrets.AWS_S3_BUCKET }}/${S3_KEY}
          
          echo "‚úÖ Uploaded $ARCHIVE_NAME to S3"
          echo "S3 path: s3://${{ secrets.AWS_S3_BUCKET }}/${S3_KEY}"
          echo "Total bugs: ${{ steps.combine-bugs.outputs.bug_count }}"
      
      - name: No bugs found
        if: steps.combine-bugs.outputs.bugs_found != 'true'
        run: |
          echo "‚úÖ No bugs found in this run, skipping S3 upload"

  update-fuzz-count:
    needs: [check-latest-build, commit-fuzzer, collect-bugs]
    if: always() && needs.commit-fuzzer.result == 'success'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout
        uses: actions/checkout@v5
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      
      - name: Install dependencies
        run: pip install boto3
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v5.1.0
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Increment fuzz count and manage schedule
        env:
          AWS_S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          PYTHONPATH: ${{ github.workspace }}
        run: |
          COMMIT_HASH="${{ needs.check-latest-build.outputs.commit_to_fuzz }}"
          python scripts/scheduling/fuzzer.py cvc5 increment $COMMIT_HASH